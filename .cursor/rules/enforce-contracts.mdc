---
description: 
globs: **/api.ts
alwaysApply: false
---
---
description: "Enforce explicit TypeScript interfaces or imported schemas for API endpoints in feature slices"
globs: ["features/*/api.ts"]
alwaysApply: false
---

# Enforce API Contracts in Feature Slices

This rule ensures that all API files in feature slices (`features/*/api.ts`) contain explicit TypeScript interfaces or imported schema definitions for requests and responses.

## Rule Requirements

### Mandatory Contract Definitions
Every `features/*/api.ts` file **must** contain at least one of the following:

#### ðŸŽ¯ **PREFERRED: Local API Contract Interfaces (Recommended for FSD)**
```typescript
// API Contract Definitions - Required by enforce-contracts rule
// These interfaces define the request/response contracts for API endpoints

/**
 * Request contract for getting items with optional filtering
 */
export interface GetItemsRequest {
  // Define request parameters
  filter?: string;
  page?: number;
}

/**
 * Response contract for items list endpoint
 */
export interface GetItemsResponse {
  // Define response structure
  items: Item[];
  total: number;
}

/**
 * Request contract for creating a new item
 */
export interface CreateItemRequest {
  // Define creation payload
  name: string;
  description?: string;
}

/**
 * Response contract for item creation endpoint
 */
export interface CreateItemResponse {
  // Define creation response
  item: Item;
  success: boolean;
}
```

#### ðŸ”„ **ALTERNATIVE: Type Aliases (When Extending Entity Types)**
```typescript
// Import entity types for reuse
import type {
  Item,
  CreateItemData,
  UpdateItemData,
  ItemsResponse,
  ItemResponse,
  ItemFilters,
} from '~/entities/item';

// API Contract Definitions (Required by enforce-contracts rule)
// Re-export or extend entity types as explicit API contracts

/**
 * Request contract extending entity filters
 */
export type GetItemsApiRequest = ItemFilters | void;

/**
 * Response contract using entity response type
 */
export type GetItemsApiResponse = ItemsResponse;

/**
 * Request contract using entity data type
 */
export type CreateItemApiRequest = CreateItemData;

/**
 * Response contract using entity response type
 */
export type CreateItemApiResponse = ItemResponse;
```

#### âš¡ **ADVANCED: Zod Schema Validation**
```typescript
// Zod schemas for runtime validation
import { z } from 'zod';

const CreateItemRequestSchema = z.object({
  name: z.string().min(1),
  description: z.string().optional(),
});

const CreateItemResponseSchema = z.object({
  item: z.object({
    id: z.string(),
    name: z.string(),
    description: z.string().optional(),
  }),
  success: z.boolean(),
});

export type CreateItemRequest = z.infer<typeof CreateItemRequestSchema>;
export type CreateItemResponse = z.infer<typeof CreateItemResponseSchema>;
```

## ðŸš¨ **Critical Requirements for FSD Architecture**

### **Why Local Contracts Are Required**

**âŒ This is NOT sufficient (Entity imports only):**
```typescript
// features/user-management/api.ts
import type { User, CreateUserData } from '~/entities/user';

// RTK Query endpoints using entity types directly
export const userApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    createUser: builder.mutation<User, CreateUserData>({
      // This lacks explicit API contracts!
    }),
  }),
});
```

**âœ… This IS required (Local API contracts):**
```typescript
// features/user-management/api.ts
import type { User, CreateUserData } from '~/entities/user';

// API Contract Definitions (Required by enforce-contracts rule)
export interface CreateUserApiRequest extends CreateUserData {
  // API-specific request structure
}

export interface CreateUserApiResponse {
  user: User;
  success: boolean;
  message?: string;
}

// RTK Query endpoints using explicit API contracts
export const userApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    createUser: builder.mutation<CreateUserApiResponse, CreateUserApiRequest>({
      // Now uses explicit API contracts!
    }),
  }),
});
```

### **Benefits of Local API Contracts**

1. **ðŸ“‹ Clear Documentation** â€” API contracts are immediately visible in the API file
2. **ðŸ” Better Discoverability** â€” Developers can see request/response shapes without jumping to entities
3. **ðŸ›¡ï¸ API-Layer Validation** â€” API-specific validation and transformation logic
4. **ðŸ”„ Easier Refactoring** â€” Changes to entities don't automatically break API contracts
5. **ðŸ“š Living Documentation** â€” API contracts serve as endpoint documentation

## Detection Patterns

This rule looks for these patterns in `features/*/api.ts` files:

### âœ… Valid Contract Patterns
- `interface ApiRequestName { ... }` or `interface ApiResponseName { ... }`
- `type ApiRequestName = { ... }` or `type ApiResponseName = { ... }`
- `export interface GetXRequest` or `export type CreateXResponse`
- `const SchemaName = z.object({...})` (Zod schemas)

### âŒ Invalid Patterns (Will Trigger Error)
- Only entity type imports without local contracts
- Only utility type imports without API-specific contracts
- API endpoints without explicit request/response typing

## Error Messages and Solutions

### **When Entity Imports Only Are Found:**
```
âŒ Entity imports detected but no local API contracts found.
âœ… Add explicit API contracts: export interface GetXRequest { ... }
âœ… Or use type aliases: export type GetXApiRequest = EntityFilter | void;
```

### **When No Contracts Are Found:**
```
âŒ Missing API contracts: please define or import TS interfaces for all API endpoints.
âœ… Add local interfaces or type aliases for request/response contracts.
âœ… See examples in .cursor/rules/enforce-contracts.mdc
```

## Integration with FSD Architecture

### **Recommended FSD API File Structure:**
```typescript
// features/user-management/api.ts

// 1. Import dependencies
import { baseApi } from '~/shared/lib/store/api';
import type { User, CreateUserData } from '~/entities/user';

// 2. API Contract Definitions (REQUIRED)
export interface GetUsersRequest {
  filter?: string;
  page?: number;
}

export interface GetUsersResponse {
  users: User[];
  total: number;
  page: number;
}

export type CreateUserApiRequest = CreateUserData;

export interface CreateUserApiResponse {
  user: User;
  success: boolean;
}

// 3. API Implementation
export const userApi = baseApi.injectEndpoints({
  endpoints: (builder) => ({
    getUsers: builder.query<GetUsersResponse, GetUsersRequest>({
      // Implementation
    }),
    createUser: builder.mutation<CreateUserApiResponse, CreateUserApiRequest>({
      // Implementation  
    }),
  }),
});
```

## Generator Integration

To automatically create compliant API files, use the enhanced generator template that includes contract definitions by default.

This rule ensures that each feature slice maintains clear, explicit contracts for its API interactions, supporting the overall architectural quality and maintainability of the FSD-based application.
