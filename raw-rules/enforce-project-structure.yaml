# === enforce-project-structure.yaml ===
id: enforce-project-structure
description: "Enforces Feature-Sliced Design (FSD) architectural methodology within the Remix app/ directory. All code organization must adhere to the standardized FSD structure"
globs:
  - "app/**/*.ts"
  - "app/**/*.tsx"
  - "app/**/*.js"
  - "app/**/*.jsx"
always_apply: true

# Project structure overview
project_structure_overview:
  description: "This project follows Feature-Sliced Design (FSD) architectural methodology within the Remix app/ directory"
  structure: |
    project-root/
    ├── app/                    ← Remix application directory
    │   ├── shared/            ← FSD shared layer
    │   ├── entities/          ← FSD entities layer
    │   ├── features/          ← FSD features layer  
    │   ├── widgets/           ← FSD widgets layer
    │   ├── pages/             ← FSD pages layer
    │   ├── routes/            ← Remix routing convention
    │   ├── entry.client.tsx   ← Remix entry points
    │   ├── entry.server.tsx   ← Remix entry points
    │   ├── root.tsx           ← Remix root component
    │   └── tailwind.css       ← Global styles
    ├── public/                ← Static assets
    ├── package.json           ← Dependencies
    └── vite.config.ts         ← Build configuration

# Required layer structure
required_layer_structure:
  description: "The app/ directory **must** contain these FSD layers when applicable:"
  layers:
    shared: "📁 app/shared/ — Reusable functionality detached from business specifics"
    entities: "📁 app/entities/ — Business entities the project works with (user, product, etc.)"
    features: "📁 app/features/ — Reusable product feature implementations that bring business value"
    widgets: "📁 app/widgets/ — Large self-contained UI chunks delivering complete use cases"
    pages: "📁 app/pages/ — Full pages or large page sections for nested routing"
  note: "Not all layers are required, but their names must follow FSD standards exactly."

# Layer-specific rules
layer_specific_rules:
  shared_layer:
    description: "Shared Layer"
    rules:
      - "**NO slices** — divide directly into segments"
      - "Structure: `app/shared/[segment]/`"
      - "Example: `app/shared/ui/`, `app/shared/lib/`, `app/shared/api/`"

  entities_features_widgets_pages_layers:
    description: "Entities, Features, Widgets, Pages Layers"
    rules:
      - "**MUST have slices** — divide by business domain first"
      - "Structure: `app/[layer]/[slice]/[segment]/`"
      - "Example: `app/pages/home/ui/`, `app/entities/user/model/`, `app/features/auth/api/`"

# Standard segments
standard_segments:
  description: "Use these conventional segment names:"
  segments:
    ui: "`ui/` — UI components, formatters, styles"
    api: "`api/` — Backend interactions, requests, data types"
    model: "`model/` — Data schemas, stores, business logic"
    lib: "`lib/` — Slice-specific library code"
    config: "`config/` — Configuration files, feature flags"

# Import rules (critical)
import_rules:
  description: "Layer Import Hierarchy (top to bottom):"
  layer_import_hierarchy:
    pages: "`app/pages/` → can import from: widgets, features, entities, shared"
    widgets: "`app/widgets/` → can import from: features, entities, shared"
    features: "`app/features/` → can import from: entities, shared"
    entities: "`app/entities/` → can import from: shared"
    shared: "`app/shared/` → can only import from: shared"

  special_remix_files:
    routes: "`app/routes/` → can import from: pages, widgets, features, entities, shared"
    root: "`app/root.tsx` → can import from: shared (for global styles/providers)"
    entry: "`app/entry.*.tsx` → can import from: shared (for initialization)"

  slice_import_rules:
    description: "Slice Import Rules:"
    rules:
      - "Slices **CANNOT** import from other slices on the same layer"
      - "This ensures high cohesion and low coupling"

# File placement requirements
file_placement_requirements:
  description: "When creating new files in app/, **always**:"
  steps:
    - "**Identify the appropriate layer** based on the code's purpose"
    - "**Create or use existing slice** (except for shared)"
    - "**Choose the correct segment** based on technical purpose"
    - "**Verify import rules** are not violated"

# Examples
examples:
  correct_structure:
    description: "✅ Correct Structure:"
    structure: |
      app/
      ├── shared/
      │   ├── ui/button.tsx
      │   ├── lib/utils.ts
      │   └── api/client.ts
      ├── entities/
      │   └── user/
      │       ├── model/types.ts
      │       └── api/requests.ts
      ├── features/
      │   └── auth/
      │       ├── ui/LoginForm.tsx
      │       └── api/login.ts
      ├── pages/
      │   └── home/
      │       └── ui/index.tsx
      ├── routes/
      │   └── _index.tsx
      ├── root.tsx
      └── tailwind.css

  incorrect_structure:
    description: "❌ Incorrect:"
    violations:
      - "`app/components/` (use `app/shared/ui/` or appropriate layer)"
      - "`app/utils/` (use `app/shared/lib/`)"
      - "`app/pages/home.tsx` (missing segments, should be `app/pages/home/ui/index.tsx`)"
      - "Cross-layer violations (features importing from widgets)"

# Before adding files
before_adding_files:
  description: "Before adding files, follow these steps:"
  checklist:
    - "**Determine layer** — What is this code's primary purpose?"
    - "**Identify slice** — What business domain does it belong to? (skip for shared)"
    - "**Choose segment** — What technical purpose does it serve?"
    - "**Check imports** — Verify no layer/slice rule violations"
    - "**Verify path** — Ensure file is inside `app/` directory"

# Remix-specific considerations
remix_specific_considerations:
  description: "Remix-specific considerations:"
  guidelines:
    routes: "**Routes**: Use `app/routes/` for Remix routing, import page components from `app/pages/`"
    global_styles: "**Global Styles**: Keep in `app/` root or `app/shared/ui/`"
    entry_points: "**Entry Points**: `app/entry.*.tsx` and `app/root.tsx` follow Remix conventions"
    build_config: "**Build Config**: `vite.config.ts` stays in project root"

# Route import rules
route_import_rules:
  required_import_pattern_for_pages:
    description: "Route files in `app/routes/` **must** import page components using relative paths:"
    correct_example: |
      // ✅ CORRECT - Relative import to ui/index.tsx
      import UserPage from '../pages/user/ui';
      export default UserPage;

  prohibited_import_patterns:
    description: "**❌ Do NOT use these import patterns in routes:**"
    wrong_examples:
      named_import: |
        // ❌ WRONG - Named import from root index
        import { UserPage } from '~/pages/user';
      direct_file_import: |
        // ❌ WRONG - Direct file import with extension
        import UserPage from '~/pages/user/ui/user.page.tsx';

  vite_alias_configuration:
    description: "Ensure `vite.config.ts` includes path alias for `~`:"
    example: |
      // vite.config.ts
      import path from 'path';

      export default defineConfig({
        resolve: {
          alias: {
            "~": path.resolve(__dirname, "./app"),
          },
        },
        // ... other config
      });

# What patterns this rule flags as problematic
anti_patterns:
  - "Files placed outside app/ directory structure"
  - "Incorrect layer naming (components/, utils/, helpers/)"
  - "Missing segments in layer structure"
  - "Cross-layer import violations"
  - "Slices importing from other slices on same layer"
  - "Incorrect file placement based on purpose"
  - "Non-FSD compliant directory structure"
  - "Routes using incorrect import patterns"
  - "Missing vite alias configuration"

# Correct approach according to this rule
correct_pattern: |
  **FSD Layer Structure:**
  ```
  app/
  ├── shared/[segment]/           # No slices, direct segments
  ├── entities/[slice]/[segment]/ # Business entities
  ├── features/[slice]/[segment]/ # Product features
  ├── widgets/[slice]/[segment]/  # UI chunks
  ├── pages/[slice]/[segment]/    # Full pages
  └── routes/                     # Remix routing
  ```

  **Import Hierarchy:**
  ```tsx
  // Pages can import from all lower layers
  import { UserWidget } from '~/widgets/user';
  import { useAuth } from '~/features/auth';
  import { User } from '~/entities/user';
  import { Button } from '~/shared/ui';

  // Features can only import from entities and shared
  import { User } from '~/entities/user';
  import { apiClient } from '~/shared/api';

  // Entities can only import from shared
  import { httpClient } from '~/shared/lib';
  ```

  **Correct File Placement:**
  ```
  app/shared/ui/Button.tsx        # Reusable UI component
  app/entities/user/model/types.ts # User business entity
  app/features/auth/ui/LoginForm.tsx # Authentication feature
  app/widgets/header/ui/Header.tsx # Header widget
  app/pages/home/ui/index.tsx     # Home page
  ```

# Patterns that trigger this rule
flagged_patterns:
  - "Files in app/components/ instead of app/shared/ui/"
  - "Files in app/utils/ instead of app/shared/lib/"
  - "Direct page files like app/pages/home.tsx"
  - "Cross-layer imports violating hierarchy"
  - "Slice-to-slice imports on same layer"
  - "Named imports from route pages"
  - "Direct file imports with extensions in routes"
  - "Missing ~ alias in vite.config.ts"

# Solutions this rule suggests
suggested_solutions:
  - "Move files to correct FSD layer based on purpose"
  - "Create proper slice/segment structure"
  - "Fix import violations to follow layer hierarchy"
  - "Use relative imports for route page components"
  - "Configure vite alias for ~ path resolution"
  - "Restructure directories to follow FSD conventions"
  - "Separate shared utilities from business logic"
  - "Organize components by business domain in features"

# Cases where this rule doesn't apply
exceptions:
  - "Remix framework files (app/entry.*.tsx, app/root.tsx)"
  - "Global configuration files (tailwind.css)"
  - "Build configuration files (vite.config.ts in root)"
  - "Static assets in public/ directory"
  - "Package configuration (package.json in root)"
  - "Legacy code during migration (temporary)"
  - "Third-party library configurations"

# Benefits of following this rule
benefits:
  - "**Scalability**: Clear structure supports large applications"
  - "**Maintainability**: Predictable file organization"
  - "**Team Collaboration**: Consistent structure across team"
  - "**Code Reusability**: Proper separation enables reuse"
  - "**Import Safety**: Layer hierarchy prevents circular dependencies"
  - "**Business Logic Separation**: Clear boundaries between domains"
  - "**FSD Compliance**: Follows proven architectural methodology"
  - "**Remix Integration**: Works seamlessly with Remix conventions" 