# === enforce-layer-boundaries.yaml ===
id: enforce-layer-boundaries
description: "Prevents direct cross-imports between different segments within the same FSD feature slice, with automatic violation detection that triggers mandatory validation workflow"
globs:
  - "app/features/**/ui/**/*.tsx"
  - "app/features/**/ui/**/*.ts"
  - "app/features/**/api.ts"
  - "app/features/**/hooks.ts"
always_apply: true

# Auto-detection patterns (triggers critical-workflow-checks validation)
auto_detection_patterns:
  critical_violations:
    description: "These patterns automatically trigger mandatory_pre_execution_validation from critical-workflow-checks"
    patterns:
      - "import.*from.*'~/widgets/.*' in app/features/"
      - "import.*from.*'~/features/.*' in app/entities/"
      - "import.*from.*'~/pages/.*' in app/widgets/"
      - "import { loginUser, fetchUserProfile } from '../api' in UI files"
      - "import.*Service.*from.*in UI components"
      - "import.*Client.*from.*in UI components"

  violation_handling:
    description: "When violations detected:"
    process:
      - "STOP execution immediately"
      - "Use critical-workflow-checks -> mandatory_pre_execution_validation -> required_conflict_response_format"
      - "Present architectural alternatives" 
      - "Wait for user decision"
    format_reference: "critical-workflow-checks.yaml -> required_conflict_response_format"

# Prohibited import patterns
prohibited_import_patterns:
  ui_layer_importing_from_api_hooks:
    description: "Do NOT import API or hooks directly in UI components"
    bad_example: |
      // ❌ BAD - Direct API import in UI component
      import { loginUser, fetchUserProfile } from '../api';
      import { useAuthState } from '../hooks';

      function LoginForm() {
        const handleSubmit = async (data: FormData) => {
          await loginUser(data); // Direct API call from UI
        };
        // ...
      }

  api_hooks_layer_importing_from_ui:
    description: "Do NOT import UI components in API or hooks files"
    bad_example: |
      // ❌ BAD - UI component import in API file
      import { showNotification } from './ui/Notification';

      export const loginUser = async (credentials: LoginData) => {
        const result = await api.login(credentials);
        showNotification('Login successful'); // UI dependency in API
        return result;
      };

# Required architecture pattern
required_architecture_pattern:
  proper_layer_separation:
    ui_components_should_only_import:
      - "Other UI components from the same feature"
      - "Hooks from the same feature (public API)"
      - "Entities, shared utilities, and external libraries"

    api_files_should_only_contain:
      - "Backend interaction logic"
      - "Data transformation"
      - "Type definitions"
      - "External API calls"

    hooks_files_should:
      - "Combine API calls with React state management"
      - "Provide the public interface for the feature"
      - "Abstract away implementation details"

# Correct implementation examples
correct_implementation_examples:
  ui_component_using_public_hook_api: |
    // app/features/auth/ui/LoginForm.tsx
    import { useAuth } from '../hooks'; // ✅ Using public hook API
    import { Button } from '~/shared/ui/Button';
    import { Form } from '~/shared/ui/Form';

    function LoginForm() {
      const { login, isLoading, error } = useAuth(); // Public API

      const handleSubmit = async (data: FormData) => {
        await login(data); // Using abstracted hook method
      };

      return (
        <Form onSubmit={handleSubmit}>
          {error && <div className="error">{error}</div>}
          <Button type="submit" disabled={isLoading}>
            {isLoading ? 'Logging in...' : 'Login'}
          </Button>
        </Form>
      );
    }

  hook_orchestrating_api_calls: |
    // app/features/auth/hooks.ts
    import { useState } from 'react';
    import { loginUser, fetchUserProfile, logoutUser } from './api'; // ✅ Hook uses API
    import type { LoginData, User } from '~/entities/user';

    export const useAuth = () => {
      const [user, setUser] = useState<User | null>(null);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);

      const login = async (credentials: LoginData) => {
        setIsLoading(true);
        setError(null);
        try {
          const result = await loginUser(credentials); // Using API layer
          const profile = await fetchUserProfile(result.userId);
          setUser(profile);
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Login failed');
        } finally {
          setIsLoading(false);
        }
      };

      const logout = async () => {
        await logoutUser(); // Using API layer
        setUser(null);
      };

      return { user, login, logout, isLoading, error };
    };

  clean_api_layer: |
    // app/features/auth/api.ts
    import { apiClient } from '~/shared/api/client';
    import type { LoginData, User, LoginResponse } from '~/entities/user';

    export const loginUser = async (credentials: LoginData): Promise<LoginResponse> => {
      const response = await apiClient.post('/auth/login', credentials);
      return response.data;
    };

    export const fetchUserProfile = async (userId: string): Promise<User> => {
      const response = await apiClient.get(`/users/${userId}`);
      return response.data;
    };

    export const logoutUser = async (): Promise<void> => {
      await apiClient.post('/auth/logout');
    };

# Architectural benefits
architectural_benefits:
  clear_separation_of_concerns:
    - "UI handles presentation and user interaction"
    - "Hooks manage state and business logic orchestration"
    - "API handles data fetching and backend communication"

  testability:
    - "Each layer can be tested independently"
    - "UI components can be tested with mocked hooks"
    - "API functions can be tested with mocked HTTP calls"

  reusability:
    - "Hooks can be used by multiple UI components"
    - "API functions can be used by different hooks"
    - "Clean interfaces make components more composable"

  maintainability:
    - "Changes to API don't directly affect UI components"
    - "UI changes don't impact backend logic"
    - "Clear boundaries make refactoring safer"

# Error messages
error_messages:
  ui_importing_from_api: |
    ❌ UI component should not directly import from API layer
    Replace: import { loginUser } from '../api'
    With: const { login } = useAuth() // Use public hook API

  ui_importing_from_hooks_incorrect: |
    ❌ Avoid importing internal hook implementations
    Replace: import { useAuthState } from '../hooks'  
    With: import { useAuth } from '../hooks' // Use public hook API

  api_importing_from_ui: |
    ❌ API layer should not import UI components
    Remove: import { showNotification } from './ui/Notification'
    Solution: Return status/error data and let UI handle presentation

  hooks_importing_from_ui: |
    ❌ Hooks should not import UI components
    Remove: import { Modal } from './ui/Modal'
    Solution: Return modal state and let UI components handle rendering

# Exception cases
exception_cases:
  description: "These imports are **allowed**:"
  within_same_segment:
    ui_components: "UI components importing other UI components: `import { LoginForm } from './LoginForm'`"
    api_functions: "API functions importing other API functions: `import { refreshToken } from './tokenApi'`"

  across_segments_following_hierarchy:
    hooks_from_api: "Hooks importing from API: `import { loginUser } from './api'` ✅"
    ui_from_hooks: "UI importing from Hooks (public API): `import { useAuth } from '../hooks'` ✅"

  external_dependencies:
    description: "Any segment importing from shared, entities, or external libraries ✅"

# Implementation guide
implementation_guide:
  to_fix_violations:
    move_logic_to_appropriate_layer:
      - "Move API calls from UI components to hooks"
      - "Move UI logic from API/hooks to UI components"
      - "Create proper abstractions in hooks layer"

    create_public_hook_apis:
      - "Export hooks that combine API calls with state management"
      - "Provide clean interfaces for UI components to consume"
      - "Abstract away implementation details"

    separate_concerns:
      - "Keep UI focused on presentation and user interaction"
      - "Keep API focused on data fetching and transformation"
      - "Use hooks as the orchestration layer between UI and API"

# Integration with FSD
integration_with_fsd:
  description: "This rule supports Feature-Sliced Design by:"
  benefits:
    - "Enforcing proper segment boundaries within feature slices"
    - "Maintaining clean separation between technical layers"
    - "Supporting the principle of dependency inversion"
    - "Enabling better testing and maintainability"
    - "Following FSD's architectural guidelines for slice organization"

# What patterns this rule flags as problematic
anti_patterns:
  - "Direct API imports in UI components"
  - "UI component imports in API files"
  - "UI component imports in hooks files"
  - "Direct database calls from UI components"
  - "Business logic in UI components"
  - "Presentation logic in API files"
  - "Cross-segment imports within same feature slice"
  - "Bypassing the hooks abstraction layer"
  - "Mixing concerns between segments"

# Correct approach according to this rule
correct_pattern: |
  **Layer Hierarchy (UI → Hooks → API):**
  ```tsx
  // UI Layer (Presentation)
  import { useAuth } from '../hooks'; // ✅ Use public hook API
  
  function LoginForm() {
    const { login, isLoading, error } = useAuth();
    // Only presentation logic here
  }

  // Hooks Layer (Orchestration)
  import { loginUser } from './api'; // ✅ Hook uses API
  
  export const useAuth = () => {
    // Combine API calls with state management
    // Provide public interface for UI
  };

  // API Layer (Data)
  export const loginUser = async (credentials) => {
    // Only backend interaction logic
    // No UI dependencies
  };
  ```

  **Dependency Flow:**
  - UI depends on Hooks (public API)
  - Hooks depend on API (data layer)
  - API depends on external services/shared utilities
  - No reverse dependencies allowed

# Patterns that trigger this rule
flagged_patterns:
  - "import.*from.*'\\.\\.?/api'" # UI importing from API
  - "import.*from.*'\\.\\.?/ui/'" # API/Hooks importing from UI
  - "import.*from.*'\\.\\.?/hooks'" # API importing from hooks (rare case)
  - "Direct API calls in UI components"
  - "UI component usage in API/hooks files"
  - "Cross-segment imports within feature slices"

# Solutions this rule suggests
suggested_solutions:
  - "Move API calls from UI components to hooks layer"
  - "Create public hook APIs that abstract implementation details"
  - "Use hooks as orchestration layer between UI and API"
  - "Keep UI focused on presentation and user interaction"
  - "Keep API focused on data fetching and transformation"
  - "Return data/state from hooks, let UI handle presentation"
  - "Use dependency injection pattern for testability"
  - "Create clean interfaces between layers"

# Cases where this rule doesn't apply
exceptions:
  - "Imports within the same segment (UI to UI, API to API)"
  - "Hooks importing from API layer (correct hierarchy)"
  - "UI importing from hooks public API (correct hierarchy)"
  - "Imports from shared utilities or entities"
  - "External library imports"
  - "Type-only imports that don't create runtime dependencies"
  - "Legacy code during migration (temporary exception)"

# Benefits of following this rule
benefits:
  - "**Clear Separation of Concerns**: Each layer has a single responsibility"
  - "**Testability**: Each layer can be tested independently"
  - "**Reusability**: Hooks can be used by multiple UI components"
  - "**Maintainability**: Changes to API don't directly affect UI"
  - "**Composability**: Clean interfaces make components more composable"
  - "**Refactoring Safety**: Clear boundaries make refactoring safer"
  - "**Code Organization**: Logical separation of technical concerns"
  - "**FSD Compliance**: Follows Feature-Sliced Design principles" 