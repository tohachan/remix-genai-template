---
meta:
  - title: Feature-Sliced Design - ProjectLearn Manager
  - name: description
    content: Understanding Feature-Sliced Design (FSD) methodology for building scalable and maintainable frontend applications.
---

# Feature-Sliced Design (FSD)

Feature-Sliced Design is an architectural methodology for building frontend applications that promotes scalability, maintainability, and team collaboration.

## Core Principles

### 1. **Layered Architecture**
FSD organizes code into hierarchical layers with strict import rules:

```
app/                    ← Application layer
├── pages/             ← Application pages
├── widgets/           ← Large UI chunks
├── features/          ← Business features  
├── entities/          ← Business entities
└── shared/            ← Reusable infrastructure
```

### 2. **Slice-Based Organization**
Within each layer (except shared), code is organized into slices by business domain:

```
features/
├── authentication/    ← Auth feature slice
├── user-profile/      ← Profile feature slice
└── task-management/   ← Task feature slice
```

### 3. **Segment Structure**
Each slice contains segments that group code by technical purpose:

```
features/authentication/
├── ui/               ← React components
├── api/              ← API requests
├── model/            ← Business logic, stores
├── lib/              ← Slice-specific utilities
└── config/           ← Configuration
```

## ProjectLearn Manager FSD Structure

Our application follows FSD methodology:

```
app/
├── pages/                     ← Page-level components
│   ├── home/
│   │   ├── ui/index.tsx
│   │   └── README.md
│   └── docs/
│       ├── ui/index.tsx
│       └── README.md
│
├── widgets/                   ← Large UI blocks
│   └── navigation/
│       ├── ui/
│       └── README.md
│
├── features/                  ← Business features
│   ├── task-management/
│   │   ├── ui/
│   │   │   ├── TaskList.tsx
│   │   │   ├── TaskForm.tsx
│   │   │   └── TaskCard.tsx
│   │   ├── api.ts
│   │   ├── hooks.ts
│   │   └── README.md
│   │
│   ├── project-management/
│   │   ├── ui/
│   │   ├── api.ts
│   │   ├── hooks.ts
│   │   └── README.md
│   │
│   └── kanban-board/
│       ├── ui/
│       ├── api.ts
│       ├── hooks.ts
│       └── README.md
│
├── entities/                  ← Business entities
│   ├── task/
│   │   ├── model/types.ts
│   │   └── index.ts
│   └── user/
│       ├── model/types.ts
│       └── index.ts
│
└── shared/                    ← Shared infrastructure
    ├── ui/                    ← Reusable components
    │   ├── button.tsx
    │   ├── card.tsx
    │   └── form.tsx
    ├── lib/                   ← Utilities
    │   ├── utils.ts
    │   └── api/
    └── config/                ← App configuration
        └── theme.ts
```

## Import Rules

FSD enforces strict import rules to maintain architectural boundaries:

### ✅ **Allowed Imports**

```tsx
// Pages can import from all lower layers
// app/pages/dashboard/ui/index.tsx
import { TaskBoard } from '~/widgets/task-board';      // widgets
import { CreateTask } from '~/features/task-management'; // features
import { Task } from '~/entities/task';                 // entities
import { Button } from '~/shared/ui/button';            // shared

// Features can import from entities and shared
// app/features/task-management/ui/TaskForm.tsx
import { Task } from '~/entities/task';         // entities
import { Button } from '~/shared/ui/button';    // shared
import { api } from '~/shared/lib/api';         // shared

// Entities can only import from shared
// app/entities/task/model/types.ts
import { BaseEntity } from '~/shared/lib/types'; // shared
```

### ❌ **Forbidden Imports**

```tsx
// ❌ Features cannot import from pages or widgets
// app/features/task-management/ui/TaskForm.tsx
import { DashboardPage } from '~/pages/dashboard'; // ❌ Higher layer

// ❌ Entities cannot import from features
// app/entities/task/model/types.ts  
import { TaskForm } from '~/features/task-management'; // ❌ Higher layer

// ❌ Slices cannot import from other slices on same layer
// app/features/task-management/ui/TaskForm.tsx
import { UserProfile } from '~/features/user-profile'; // ❌ Same layer
```

## Practical Example: Task Management Feature

Let's examine how our task management feature follows FSD:

### Entity Layer: Task Types
```tsx
// app/entities/task/model/types.ts
export interface Task {
  id: string;
  title: string;
  description: string;
  status: 'todo' | 'in-progress' | 'done';
  priority: 'low' | 'medium' | 'high';
  deadline?: Date;
  assignee?: string;
  projectId: string;
}

export interface CreateTaskData {
  title: string;
  description: string;
  priority: Task['priority'];
  deadline?: Date;
  projectId: string;
}
```

### Feature Layer: Task Management
```tsx
// app/features/task-management/api.ts
import { api } from '~/shared/lib/api';
import { Task, CreateTaskData } from '~/entities/task';

export const taskApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getTasks: builder.query<Task[], void>({
      query: () => '/tasks',
    }),
    createTask: builder.mutation<Task, CreateTaskData>({
      query: (task) => ({
        url: '/tasks',
        method: 'POST',
        body: task,
      }),
    }),
  }),
});

// app/features/task-management/hooks.ts
import { taskApi } from './api';

export const useTasks = () => {
  const { data: tasks = [], isLoading } = taskApi.useGetTasksQuery();
  const [createTask] = taskApi.useCreateTaskMutation();
  
  return { tasks, isLoading, createTask };
};

// app/features/task-management/ui/TaskForm.tsx
import { Button } from '~/shared/ui/button';
import { Input } from '~/shared/ui/input';
import { CreateTaskData } from '~/entities/task';
import { useTasks } from '../hooks';

export function TaskForm() {
  const { createTask } = useTasks();
  
  const handleSubmit = async (data: CreateTaskData) => {
    await createTask(data);
  };

  return (
    <form onSubmit={handleSubmit}>
      <Input name="title" placeholder="Task title" />
      <Input name="description" placeholder="Task description" />
      <Button type="submit">Create Task</Button>
    </form>
  );
}
```

### Page Layer: Dashboard
```tsx
// app/pages/dashboard/ui/index.tsx
import { TaskBoard } from '~/widgets/task-board';
import { CreateTask } from '~/features/task-management';

export function DashboardPage() {
  return (
    <div>
      <h1>Project Dashboard</h1>
      <CreateTask />
      <TaskBoard />
    </div>
  );
}
```

## Benefits of FSD

### 1. **Scalability**
- Clear boundaries prevent feature coupling
- New features can be added without affecting existing ones
- Teams can work independently on different slices

### 2. **Maintainability**
- Each layer has a specific responsibility
- Import rules prevent architectural violations
- Code is organized by business logic, not technical implementation

### 3. **Team Collaboration**
- Features can be developed in parallel
- Clear ownership boundaries
- Consistent structure across the codebase

### 4. **Testing Strategy**
- Each layer can be tested independently
- Business logic is separated from UI concerns
- Shared utilities are easily testable

## Common Patterns in Our Application

### 1. **API + Hooks Pattern**
```tsx
// Feature exposes hooks that wrap API calls
export const useTaskManagement = () => {
  const { data: tasks } = taskApi.useGetTasksQuery();
  const [createTask] = taskApi.useCreateTaskMutation();
  
  return { tasks, createTask };
};
```

### 2. **Component + Container Pattern**  
```tsx
// UI component receives props
export function TaskCard({ task, onEdit, onDelete }) {
  return (
    <Card>
      <h3>{task.title}</h3>
      <button onClick={() => onEdit(task)}>Edit</button>
    </Card>
  );
}

// Container handles logic
export function TaskCardContainer({ taskId }) {
  const { task } = useTask(taskId);
  const { editTask, deleteTask } = useTaskActions();
  
  return (
    <TaskCard 
      task={task}
      onEdit={editTask}
      onDelete={deleteTask}
    />
  );
}
```

### 3. **Index File Exports**
```tsx
// app/features/task-management/index.ts
export { TaskForm } from './ui/TaskForm';
export { TaskList } from './ui/TaskList';
export { useTasks } from './hooks';
```

## Best Practices

1. **Keep slices focused**: Each slice should represent a single business capability
2. **Use public APIs**: Export only what other layers need to consume
3. **Follow naming conventions**: Use descriptive, business-focused names
4. **Document decisions**: Include README.md files explaining slice purpose
5. **Validate imports**: Use linting rules to enforce layer boundaries

FSD provides a solid foundation for building scalable React applications by enforcing clear architectural boundaries and promoting good separation of concerns. 