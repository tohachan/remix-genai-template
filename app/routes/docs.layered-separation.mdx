---
meta:
  - title: Layered Separation - ProjectLearn Manager
  - name: description
    content: Learn how to implement proper layered architecture and separation of concerns in React applications.
---

# Layered Separation

Layered separation is an architectural pattern that organizes code into distinct layers, each with specific responsibilities and clear boundaries.

## The Problem

Without proper layered separation, applications often become:
- Difficult to test
- Hard to maintain
- Tightly coupled
- Prone to circular dependencies

## Our Layer Structure

ProjectLearn Manager follows a clear layered architecture:

### 1. **Presentation Layer (UI)**
- React components
- User interaction handling
- UI state management

### 2. **Business Logic Layer (Hooks)**
- Application business rules
- Data orchestration
- State management

### 3. **Data Access Layer (API)**
- External service communication
- Data fetching and mutations
- Caching logic

### 4. **Infrastructure Layer (Shared)**
- Utilities and helpers
- Configuration
- Third-party integrations

## Example: Task Management

```tsx
// ❌ BAD: Mixed concerns
function TaskList() {
  const [tasks, setTasks] = useState([]);
  
  // Data fetching mixed with UI
  useEffect(() => {
    fetch('/api/tasks')
      .then(res => res.json())
      .then(setTasks);
  }, []);
  
  // Business logic in UI component
  const completedTasks = tasks.filter(t => t.status === 'done');
  const progress = (completedTasks.length / tasks.length) * 100;
  
  return (
    <div>
      <h2>Tasks ({progress.toFixed(1)}% complete)</h2>
      {tasks.map(task => (
        <div key={task.id}>
          <h3>{task.title}</h3>
          <button onClick={() => {
            // API call in UI component
            fetch(`/api/tasks/${task.id}`, {
              method: 'PATCH',
              body: JSON.stringify({ status: 'done' })
            });
          }}>
            Complete
          </button>
        </div>
      ))}
    </div>
  );
}

// ✅ GOOD: Separated layers

// Data Layer
export const taskApi = {
  getTasks: () => fetch('/api/tasks').then(res => res.json()),
  updateTask: (id, data) => 
    fetch(`/api/tasks/${id}`, {
      method: 'PATCH',
      body: JSON.stringify(data)
    })
};

// Business Logic Layer  
export const useTaskManagement = () => {
  const [tasks, setTasks] = useState([]);
  
  const loadTasks = useCallback(async () => {
    const data = await taskApi.getTasks();
    setTasks(data);
  }, []);
  
  const completeTask = useCallback(async (taskId) => {
    await taskApi.updateTask(taskId, { status: 'done' });
    loadTasks(); // Refresh data
  }, [loadTasks]);
  
  const completedTasks = useMemo(
    () => tasks.filter(t => t.status === 'done'),
    [tasks]
  );
  
  const progress = useMemo(
    () => tasks.length ? (completedTasks.length / tasks.length) * 100 : 0,
    [completedTasks.length, tasks.length]
  );
  
  return { tasks, progress, completeTask, loadTasks };
};

// Presentation Layer
export function TaskList() {
  const { tasks, progress, completeTask } = useTaskManagement();
  
  return (
    <div>
      <h2>Tasks ({progress.toFixed(1)}% complete)</h2>
      {tasks.map(task => (
        <TaskCard 
          key={task.id} 
          task={task} 
          onComplete={() => completeTask(task.id)}
        />
      ))}
    </div>
  );
}

function TaskCard({ task, onComplete }) {
  return (
    <div>
      <h3>{task.title}</h3>
      <button onClick={onComplete}>Complete</button>
    </div>
  );
}
```

## Benefits

1. **Testability**: Each layer can be tested independently
2. **Maintainability**: Changes are isolated to specific layers
3. **Reusability**: Business logic can be reused across components
4. **Separation of Concerns**: Each layer has a single responsibility

Proper layered separation creates more maintainable and scalable applications. 